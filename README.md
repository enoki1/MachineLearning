# MachineLearning
-------
# Индивидуальные задачи
 # 1)Метрики. Алгоритм Нидлмана-Вунша.
    
    Есть две последовательности, надо провести выравнивание. Для этого динамикой заполняется таблица n x m, где n,m - длины последовательностей. 
    Таблица заполняется таким образом что на каждой итерации выбирается минимум из предложенных действий(удаление, вставка, замена).
    В ячейке (n+1)(m+1) хранится ответ - Расстояние Левенштейна. Для поиска действий для выравнивания я прошелся обратно запоминая какие действия выбирал во время минимизирования
     
    Для последовательностей длиной >10^5 я получал ответ в течении 16-17 минут(скрин не сохранил), что очень долго. Скорее всего не стоило запоминать всю таблицу
    размером 10^5 на 10^5, это слишком много, но тогда я не смогу определить какие действия для выравнивания совершал.
    Вот как выглядит вывод для произвольных последовательностей(V - вставка, Z - замена, U - удаление)
![Image alt](images/Nidl.png)  
    
    не понимаю как ускорить работу алгоритма
    Весь код: https://github.com/enoki1/MachineLearning/blob/main/Nidlmann.py
    
 # 2)Классификация в непрерывном пространстве.Школы и жители
  1) Есть сетка(город(квадратный)) внутри сетки выбираются точки(люди) в узлах школы, человек может ходить лишь только по улицам, найти школу к которой человек относится
 заданы прямые k1 и k2 штук(заданы коодринаты школ) далее набор координат жителей. найти ближайшую школу для человека(ходим только по сетке, когда мы в одной клетке то можем шагнуть перпендикулярно)

  # Начальные условия:
   1) Город квадратный
   2) Сетка равномерная
   
 # Описание метода
   
  Научиться быстро решать эту задачу у меня не получилось, в конечном итоге все свелось к нехитрому перебору и геометрии на плоскости. Пытался реализовать алгоритм Форчуна, но сделать это без каких-либо доп.библиотек не получилось
  Весь код: https://github.com/enoki1/MachineLearning/blob/main/Schools.py
  
#  3)Кластеризация на плоскости.
    Нужно было сгенерировать некоторые точки на плоскости и попробовать их разделить на кластеры.
   # Генерация 
        Программа на вход принимает число окружностей  и число точек внутри каждой окружности. Далее я ввожу центры окружностей и их радиусы. Внутри каждой окружности я случайным образом генерирую точки. Это было сделано для облегчения проверки ответа.
   # Алгоритм
       Для приблизительного анализа числа кластеров использовался метод иерархической кластеризации, благодаря которому я находил примерное число кластеров и изначальные положения центроидов.
       Далее я реализовал алгоритм K-MEANS, с помощью которого провел кластеризацию
  # Тесты
  
  ![](images/кластеры1.png)  
      Здесь будет 5 окружностей, всего около 10000 точек, коэффициент "похожести" равен 30. Этот коэффициент позволяет определяет какие элементы мы считаем близкими, а какие нет. Далее идут координаты окружностей и их радиусы. К Слову, такая скорость выполнения меня устраивает.
      Вывод в этом случае:
  ![](images/кластеры2.png)
  
  Второй тест(более очевидный для проверки)
  
  ![](images/кластеры3.png)
  
  Вывод :
  ![](images/кластеры4.png)
    Легко проверить что кластеризация выполнилось верно, точки внутри окружностей с центром в (1,1) и (10,10) соединились. Всего кластеров 4
